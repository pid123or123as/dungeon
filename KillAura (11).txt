local KillAura = {}

function KillAura.Init(UI, Core, notify)
    local ReplicatedStorage = Core.Services.ReplicatedStorage
    local CollectionService = game:GetService("CollectionService")
    local TNetSent = ReplicatedStorage:WaitForChild("TNetSent")
    local Workspace = Core.Services.Workspace
    local Players = Core.Services.Players
    local LocalPlayer = Core.PlayerData.LocalPlayer
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    local RunService = Core.Services.RunService

    -- Initialize Core.DungeonLootify
    Core.DungeonLootify = Core.DungeonLootify or { TargetCount = 0 }

    -- Configuration
    local Settings = {
        Enabled = { Value = false, Default = false },
        MaxDistance = { Value = 100, Default = 100 },
        EnableCluster = { Value = true, Default = true },
        ClusterRadius = { Value = 8, Default = 8 },
        AttackHeight = { Value = 2, Default = 2 },
        UseRaycast = { Value = false, Default = false },
        TestPredict = { Value = true, Default = true },
        PredictValue = { Value = 0.2, Default = 0.2 },
        UpdateInterval = { Value = 0.05, Default = 0.05 },
        DebugLogs = { Value = true, Default = true },
        ShowCircles = { Value = true, Default = true },
        TargetESP = {
            Enabled = { Value = false, Default = false },
            PartsCount = { Value = 30, Default = 30 },
            GradientSpeed = { Value = 4, Default = 4 },
            CircleDistance = { Value = 2, Default = 2 },
            YOffset = { Value = 0, Default = 0 },
            AnimateCircle = { Value = "Jello", Default = "Jello" },
            AnimationSpeed = { Value = 2, Default = 2 },
            OrbitTilt = { Value = 0.7, Default = 0.7 }
        }
    }

    -- UI Elements storage
    local uiElements = {}

    -- Ignored folders
    local ignoreFolders = {"Bullet", "Debris", "Func", "EnvSound", "Ornament", "Rank"}

    -- Visualization using Drawing API
    local Drawing = Drawing or {}
    local indicators = {}
    local targetESPQuads = {}
    local targetESPBlurQuads = {}
    local targetESPOppositeQuads = {}
    local lastTarget = nil
    local cachedTargets = {}
    local lastTargetUpdate = 0
    local invokeID = math.random(1, 10000)
    local slashCounter = {}
    local hitNumCounter = {}
    local currentWeaponCache = nil
    local lastWeaponCheck = 0

    -- Cleanup function for Drawing objects
    local function cleanupDrawingObjects()
        for _, indicator in ipairs(indicators) do
            if indicator.circle and indicator.circle.Remove then
                indicator.circle:Remove()
            end
            if indicator.connection then
                indicator.connection:Disconnect()
            end
        end
        table.clear(indicators)

        for _, quad in ipairs(targetESPQuads) do
            if quad and quad.Remove then
                quad:Remove()
            end
        end
        table.clear(targetESPQuads)

        for _, blurQuad in ipairs(targetESPBlurQuads) do
            if blurQuad and blurQuad.Remove then
                blurQuad:Remove()
            end
        end
        table.clear(targetESPBlurQuads)

        for _, oppositeQuad in ipairs(targetESPOppositeQuads) do
            if oppositeQuad and oppositeQuad.Remove then
                oppositeQuad:Remove()
            end
        end
        table.clear(targetESPOppositeQuads)

        if Settings.DebugLogs.Value then
            print("Drawing objects cleaned up")
        end
    end

    -- Attack visualization
    local function createAttackIndicator(position)
        if not Settings.ShowCircles.Value then return end
        local circle = Drawing.new("Circle")
        circle.Visible = true
        circle.Color = Color3.new(1, 0, 0) -- Red
        circle.Thickness = 2
        circle.NumSides = 32
        circle.Radius = 5
        circle.Filled = false
        circle.Position = Vector2.new(0, 0)
        circle.ZIndex = 1000

        local updateConn = RunService.RenderStepped:Connect(function()
            local screenPos, onScreen = Core.PlayerData.Camera:WorldToViewportPoint(position)
            circle.Visible = onScreen and Settings.ShowCircles.Value
            if onScreen then
                circle.Position = Vector2.new(screenPos.X, screenPos.Y)
            end
        end)

        table.insert(indicators, { circle = circle, connection = updateConn })
        task.delay(0.5, function()
            if circle and circle.Remove then
                circle:Remove()
            end
            if updateConn then
                updateConn:Disconnect()
            end
            for i, indicator in ipairs(indicators) do
                if indicator.circle == circle then
                    table.remove(indicators, i)
                    break
                end
            end
        end)
    end

    local function createMultiTargetIndicator(position)
        if not Settings.ShowCircles.Value then return end
        local circle = Drawing.new("Circle")
        circle.Visible = true
        circle.Color = Color3.new(0, 1, 0) -- Green
        circle.Thickness = 2
        circle.NumSides = 32
        circle.Radius = 7
        circle.Filled = true
        circle.Position = Vector2.new(0, 0)
        circle.ZIndex = 999

        local updateConn = RunService.RenderStepped:Connect(function()
            local screenPos, onScreen = Core.PlayerData.Camera:WorldToViewportPoint(position)
            circle.Visible = onScreen and Settings.ShowCircles.Value
            if onScreen then
                circle.Position = Vector2.new(screenPos.X, screenPos.Y)
            end
        end)

        table.insert(indicators, { circle = circle, connection = updateConn })
        task.delay(0.5, function()
            if circle and circle.Remove then
                circle:Remove()
            end
            if updateConn then
                updateConn:Disconnect()
            end
            for i, indicator in ipairs(indicators) do
                if indicator.circle == circle then
                    table.remove(indicators, i)
                    break
                end
            end
        end)
    end

    local function interpolateColor(color1, color2, factor)
        return Color3.new(
            color1.R + (color2.R - color1.R) * factor,
            color1.G + (color2.G - color1.G) * factor,
            color1.B + (color2.B - color1.B) * factor
        )
    end

    local function getTargetRootPart()
        if cachedTargets and #cachedTargets > 0 then
            return cachedTargets[1].part
        end
        return nil
    end

    local function createTargetESP()
        local rootPart = getTargetRootPart()
        if not rootPart then return end

        cleanupDrawingObjects() -- Clear existing ESP quads

        local partsCount = Settings.TargetESP.PartsCount.Value
        for i = 1, partsCount do
            local quad = Drawing.new("Quad")
            quad.Visible = false
            quad.Thickness = (Settings.TargetESP.AnimateCircle.Value == "Orbit" or Settings.TargetESP.AnimateCircle.Value == "OrbitSwirl") and 1.5 or 1
            quad.Filled = false
            quad.Color = interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, i / partsCount)
            quad.ZIndex = 1001
            table.insert(targetESPQuads, quad)

            local oppositeQuad = Drawing.new("Quad")
            oppositeQuad.Visible = false
            oppositeQuad.Thickness = (Settings.TargetESP.AnimateCircle.Value == "Orbit" or Settings.TargetESP.AnimateCircle.Value == "OrbitSwirl") and 1.5 or 1
            oppositeQuad.Filled = false
            oppositeQuad.Color = quad.Color
            oppositeQuad.ZIndex = 1001
            table.insert(targetESPOppositeQuads, oppositeQuad)
        end

        if Settings.TargetESP.AnimateCircle.Value == "Orbit" or Settings.TargetESP.AnimateCircle.Value == "OrbitSwirl" then
            for i = 1, partsCount do
                local blurQuad = Drawing.new("Quad")
                blurQuad.Visible = false
                blurQuad.Thickness = 1.5
                blurQuad.Filled = true
                blurQuad.Color = targetESPQuads[i].Color
                blurQuad.Transparency = 0.3
                blurQuad.ZIndex = 1000
                table.insert(targetESPBlurQuads, blurQuad)
            end
        end
    end

    local function updateTargetESP()
        if not Settings.TargetESP.Enabled.Value then
            cleanupDrawingObjects()
            if Settings.DebugLogs.Value then print("TargetESP disabled") end
            return
        end

        local rootPart = getTargetRootPart()
        if not rootPart then
            cleanupDrawingObjects()
            lastTarget = nil
            if Settings.DebugLogs.Value then print("No target for ESP") end
            return
        end

        local currentTargetName = rootPart.Parent.Name
        if currentTargetName ~= lastTarget then
            lastTarget = currentTargetName
            createTargetESP()
            if Settings.DebugLogs.Value then print("TargetESP created for: " .. currentTargetName) end
        end

        local t = tick()
        local yOffset
        if Settings.TargetESP.AnimateCircle.Value == "Jello" then
            yOffset = math.sin(t * Settings.TargetESP.AnimationSpeed.Value) * 2.75 - 0.25
        elseif Settings.TargetESP.AnimateCircle.Value == "Orbit" then
            yOffset = math.sin(t * Settings.TargetESP.AnimationSpeed.Value) * 0.5
        else
            yOffset = Settings.TargetESP.YOffset.Value
        end

        local center = Vector3.new(rootPart.Position.X, rootPart.Position.Y + yOffset, rootPart.Position.Z)
        local screenCenter, onScreenCenter = Core.PlayerData.Camera:WorldToViewportPoint(center)
        if not (onScreenCenter and screenCenter.Z > 0) then
            for _, quad in ipairs(targetESPQuads) do
                quad.Visible = false
            end
            for _, blurQuad in ipairs(targetESPBlurQuads) do
                blurQuad.Visible = false
            end
            for _, oppositeQuad in ipairs(targetESPOppositeQuads) do
                oppositeQuad.Visible = false
            end
            return
        end

        local espRadius = Settings.TargetESP.CircleDistance.Value
        local partsCount = #targetESPQuads
        for i, quad in ipairs(targetESPQuads) do
            local angleOffset
            if Settings.TargetESP.AnimateCircle.Value == "Jello" then
                angleOffset = math.sin(t * Settings.TargetESP.AnimationSpeed.Value) * 0.2
            elseif Settings.TargetESP.AnimateCircle.Value == "OrbitSwirl" then
                angleOffset = t * (Settings.TargetESP.AnimationSpeed.Value * 0.75)
            else
                angleOffset = 0
            end

            local angle1 = ((i - 1) / partsCount) * 2 * math.pi + angleOffset
            local angle2 = (i / partsCount) * 2 * math.pi + angleOffset
            local oppositeAngle1 = -angle1
            local oppositeAngle2 = -angle2

            local depthOffset = (Settings.TargetESP.AnimateCircle.Value == "Orbit" or Settings.TargetESP.AnimateCircle.Value == "OrbitSwirl") and
                (math.cos(t * Settings.TargetESP.AnimationSpeed.Value + (i / partsCount) * 2 * math.pi) * Settings.TargetESP.OrbitTilt.Value * 0.5) or 0
            local point1 = center + Vector3.new(math.cos(angle1) * espRadius, depthOffset, math.sin(angle1) * espRadius)
            local point2 = center + Vector3.new(math.cos(angle2) * espRadius, depthOffset, math.sin(angle2) * espRadius)

            local screenPoint1, onScreen1 = Core.PlayerData.Camera:WorldToViewportPoint(point1)
            local screenPoint2, onScreen2 = Core.PlayerData.Camera:WorldToViewportPoint(point2)

            if onScreen1 and onScreen2 and screenPoint1.Z > 0 and screenPoint2.Z > 0 then
                quad.PointA = Vector2.new(screenPoint1.X, screenPoint1.Y)
                quad.PointB = Vector2.new(screenPoint2.X, screenPoint2.Y)
                quad.PointC = Vector2.new(screenPoint2.X, screenPoint2.Y)
                quad.PointD = Vector2.new(screenPoint1.X, screenPoint1.Y)
                quad.Visible = true

                quad.Color = interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, (math.sin(t * Settings.TargetESP.GradientSpeed.Value + (i / partsCount) * 2 * math.pi) + 1) / 2)

                local oppositeQuad = targetESPOppositeQuads[i]
                local oppPoint1 = center + Vector3.new(math.cos(oppositeAngle1) * espRadius, -depthOffset, math.sin(oppositeAngle1) * espRadius)
                local oppPoint2 = center + Vector3.new(math.cos(oppositeAngle2) * espRadius, -depthOffset, math.sin(oppositeAngle2) * espRadius)

                local screenOppPoint1, onScreenOpp1 = Core.PlayerData.Camera:WorldToViewportPoint(oppPoint1)
                local screenOppPoint2, onScreenOpp2 = Core.PlayerData.Camera:WorldToViewportPoint(oppPoint2)

                if onScreenOpp1 and onScreenOpp2 and screenOppPoint1.Z > 0 and screenOppPoint2.Z > 0 then
                    oppositeQuad.PointA = Vector2.new(screenOppPoint1.X, screenOppPoint1.Y)
                    oppositeQuad.PointB = Vector2.new(screenOppPoint2.X, screenOppPoint2.Y)
                    oppositeQuad.PointC = Vector2.new(screenOppPoint2.X, screenOppPoint2.Y)
                    oppositeQuad.PointD = Vector2.new(screenOppPoint1.X, screenOppPoint1.Y)
                    oppositeQuad.Visible = true
                    oppositeQuad.Color = quad.Color
                else
                    oppositeQuad.Visible = false
                end
            else
                quad.Visible = false
                targetESPOppositeQuads[i].Visible = false
            end
        end

        if Settings.TargetESP.AnimateCircle.Value == "Orbit" or Settings.TargetESP.AnimateCircle.Value == "OrbitSwirl" then
            for i, blurQuad in ipairs(targetESPBlurQuads) do
                local angle1 = ((i - 1) / partsCount) * 2 * math.pi + (Settings.TargetESP.AnimateCircle.Value == "OrbitSwirl" and (t * (Settings.TargetESP.AnimationSpeed.Value * 0.75)) or 0)
                local angle2 = (i / partsCount) * 2 * math.pi + (Settings.TargetESP.AnimateCircle.Value == "OrbitSwirl" and (t * (Settings.TargetESP.AnimationSpeed.Value * 0.75)) or 0)
                local blurOffset = 0.05
                local blurCenter = Vector3.new(rootPart.Position.X, rootPart.Position.Y + yOffset - blurOffset, rootPart.Position.Z)
                local blurPoint1 = blurCenter + Vector3.new(math.cos(angle1) * espRadius, depthOffset, math.sin(angle1) * espRadius)
                local blurPoint2 = blurCenter + Vector3.new(math.cos(angle2) * espRadius, depthOffset, math.sin(angle2) * espRadius)

                local screenBlurPoint1, onScreenBlur1 = Core.PlayerData.Camera:WorldToViewportPoint(blurPoint1)
                local screenBlurPoint2, onScreenBlur2 = Core.PlayerData.Camera:WorldToViewportPoint(blurPoint2)

                if onScreenBlur1 and onScreenBlur2 and screenBlurPoint1.Z > 0 and screenBlurPoint2.Z > 0 then
                    blurQuad.PointA = Vector2.new(screenBlurPoint1.X, screenBlurPoint1.Y)
                    blurQuad.PointB = Vector2.new(screenBlurPoint2.X, screenBlurPoint2.Y)
                    blurQuad.PointC = Vector2.new(screenBlurPoint2.X, screenBlurPoint2.Y)
                    blurQuad.PointD = Vector2.new(screenBlurPoint1.X, screenBlurPoint1.Y)
                    blurQuad.Visible = true
                    blurQuad.Color = targetESPQuads[i].Color
                else
                    blurQuad.Visible = false
                end
            end
        end
    end

    -- RunService.RenderStepped for ESP
    RunService.RenderStepped:Connect(function()
        if Settings.TargetESP.Enabled.Value then
            updateTargetESP()
        end
    end)

    -- Load CombatConfig
    local CombatConfig = require(ReplicatedStorage:WaitForChild("Config"):WaitForChild("Program"):WaitForChild("CombatConfig"))

    -- Find targets
    local function findAllTargets()
        local startTime = tick()
        local targets = {}
        local modelsChecked = {}
        local playerNames = {}
        for _, player in ipairs(Players:GetPlayers()) do
            table.insert(playerNames, player.Name)
        end

        local function checkModel(model)
            if not model.Parent or table.find(ignoreFolders, model.Parent.Name) then return end
            if table.find(playerNames, model.Name) then return end
            if model:IsA("Model") and model ~= Character and model ~= LocalPlayer.Character and not Players:GetPlayerFromCharacter(model) and not modelsChecked[model] then
                modelsChecked[model] = true
                if #model.Name == 7 then return end
                local humanoid = model:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local targetPart = model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart
                    if targetPart and targetPart:IsA("BasePart") then
                        local dist = (HumanoidRootPart.Position - targetPart.Position).Magnitude
                        if dist <= Settings.MaxDistance.Value then
                            if Settings.UseRaycast.Value then
                                local rayParams = RaycastParams.new()
                                rayParams.FilterDescendantsInstances = {Character}
                                rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                                local result = Workspace:Raycast(HumanoidRootPart.Position, (targetPart.Position - HumanoidRootPart.Position).Unit * dist, rayParams)
                                if result and result.Instance:IsDescendantOf(model) then
                                    table.insert(targets, { model = model, part = targetPart, distance = dist })
                                elseif Settings.DebugLogs.Value then
                                    warn("Target " .. model.Name .. " skipped: part " .. (targetPart and targetPart.Name or "nil") .. " not visible")
                                end
                            else
                                table.insert(targets, { model = model, part = targetPart, distance = dist })
                            end
                        end
                    elseif Settings.DebugLogs.Value then
                        warn("No valid HumanoidRootPart/PrimaryPart in model: " .. model.Name)
                    end
                end
            end
        end

        local overlapParams = OverlapParams.new()
        overlapParams.FilterDescendantsInstances = {Character}
        overlapParams.FilterType = Enum.RaycastFilterType.Blacklist
        overlapParams.MaxParts = 1000
        local parts = Workspace:GetPartBoundsInBox(CFrame.new(HumanoidRootPart.Position), Vector3.new(Settings.MaxDistance.Value * 2, Settings.MaxDistance.Value * 2, Settings.MaxDistance.Value * 2), overlapParams)
        for _, part in ipairs(parts) do
            local model = part:FindFirstAncestorOfClass("Model")
            if model then
                checkModel(model)
            end
        end

        if #targets == 0 then
            local taggedNPCs = CollectionService:GetTagged("NPC")
            for _, model in ipairs(taggedNPCs) do
                checkModel(model)
            end
        end

        table.sort(targets, function(a, b) return a.distance < b.distance end)
        Core.DungeonLootify.TargetCount = #targets
        if Settings.DebugLogs.Value then
            print("Targets found: " .. #targets .. " | Search time: " .. (tick() - startTime))
            print("Core.DungeonLootify.TargetCount updated to: " .. Core.DungeonLootify.TargetCount)
        end
        return targets
    end

    -- Get current weapon
    local function getCurrentWeapon()
        if tick() - lastWeaponCheck < 0.5 and currentWeaponCache then return unpack(currentWeaponCache) end
        for _, tool in ipairs(Character:GetChildren()) do
            if tool:IsA("Tool") then
                local weaponType = tool:GetAttribute("Type") or "DuoSword"
                currentWeaponCache = {tool, weaponType}
                lastWeaponCheck = tick()
                return tool, weaponType
            end
        end
        return nil, nil
    end

    -- Average CFrame for cluster with prediction
    local function getAverageCFrame(cluster, heightOffset)
        if #cluster == 0 then return nil end
        local multiTargetPos = nil
        if #cluster == 1 then
            local targetPart = cluster[1].part
            if not targetPart or not targetPart:IsA("BasePart") then
                if Settings.DebugLogs.Value then
                    warn("Single target has no valid part: " .. cluster[1].model.Name)
                end
                return nil
            end
            local basePos = targetPart.Position
            if Settings.TestPredict.Value then
                local predictOffset = Vector3.new(0, 0, 0)
                if targetPart and targetPart.Velocity then
                    predictOffset = targetPart.Velocity * Settings.PredictValue.Value
                    if Settings.DebugLogs.Value then
                        print("Predict offset for " .. cluster[1].model.Name .. ": " .. tostring(predictOffset.Magnitude))
                    end
                end
                basePos = basePos + predictOffset
            end
            return CFrame.new(basePos) * CFrame.new(0, heightOffset, 0) * targetPart.CFrame.Rotation, nil
        end

        local totalPos = Vector3.new(0, 0, 0)
        local count = 0
        local nearestCFrame = nil
        for _, target in ipairs(cluster) do
            local targetPart = target.part
            if not targetPart or not targetPart:IsA("BasePart") then
                if Settings.DebugLogs.Value then
                    warn("Cluster target has no valid part: " .. target.model.Name)
                end
                continue
            end
            local pos = targetPart.Position
            if Settings.TestPredict.Value then
                local predictOffset = Vector3.new(0, 0, 0)
                if targetPart.Velocity then
                    predictOffset = targetPart.Velocity * Settings.PredictValue.Value
                    if Settings.DebugLogs.Value then
                        print("Predict offset for " .. target.model.Name .. ": " .. tostring(predictOffset.Magnitude))
                    end
                end
                pos = pos + predictOffset
            end
            totalPos = totalPos + pos
            count = count + 1
            if not nearestCFrame then
                nearestCFrame = targetPart.CFrame
            end
        end
        if count == 0 then
            if Settings.DebugLogs.Value then
                warn("No valid parts in cluster")
            end
            return nil
        end
        local avgPos = totalPos / count
        multiTargetPos = avgPos
        return CFrame.new(avgPos) * CFrame.new(0, heightOffset, 0) * (nearestCFrame or CFrame.new()), multiTargetPos
    end

    -- Group targets by proximity
    local function groupTargetsByProximity(targets, clusterRadius)
        local clusters = {}
        local used = {}
        for i, target in ipairs(targets) do
            if not used[i] then
                local cluster = {target}
                used[i] = true
                for j, other in ipairs(targets) do
                    if not used[j] and i ~= j then
                        local dist = (target.part.Position - other.part.Position).Magnitude
                        if dist <= clusterRadius then
                            table.insert(cluster, other)
                            used[j] = true
                        end
                    end
                end
                if #cluster >= 2 then
                    table.insert(clusters, cluster)
                end
            end
        end
        if #clusters == 0 and #targets > 0 then
            table.insert(clusters, {targets[1]})
        end
        return clusters
    end

    -- Main KillAura loop
    local killAuraCoroutine = nil
    local function runKillAura()
        while Settings.Enabled.Value do
            local interval = #cachedTargets > 0 and 0.5 or Settings.UpdateInterval.Value
            if tick() - lastTargetUpdate >= interval or #cachedTargets == 0 then
                cachedTargets = findAllTargets()
                lastTargetUpdate = tick()
            end
            if #cachedTargets == 0 then 
                Core.DungeonLootify.TargetCount = 0
                if Settings.DebugLogs.Value then 
                    warn("No valid NPC targets!")
                    print("Core.DungeonLootify.TargetCount set to: 0")
                end
                task.wait(0.3)
                continue 
            end

            local tool, weaponType = getCurrentWeapon()
            if not tool or not weaponType then 
                if Settings.DebugLogs.Value then warn("No weapon equipped!") end
                task.wait(0.3)
                continue 
            end

            if not slashCounter[weaponType] then
                slashCounter[weaponType] = 1
                hitNumCounter[weaponType] = 1
            end

            local weaponConfig = CombatConfig[weaponType] or CombatConfig
            local slashLimit = weaponConfig.slashLimit or 1
            local slashHit = weaponConfig.slashHit or 1

            local clusters = Settings.EnableCluster.Value and groupTargetsByProximity(cachedTargets, Settings.ClusterRadius.Value) or {{cachedTargets[1]}}
            for _, cluster in ipairs(clusters) do
                local attackCFrame, multiTargetPos = getAverageCFrame(cluster, Settings.AttackHeight.Value)
                if attackCFrame then
                    createAttackIndicator(attackCFrame.Position)
                    if multiTargetPos and #cluster >= 2 and Settings.EnableCluster.Value then
                        createMultiTargetIndicator(multiTargetPos)
                    end
                    local args = {
                        [1] = "Weapon_OnHit",
                        [2] = invokeID,
                        [3] = Workspace:GetServerTimeNow(),
                        [4] = slashCounter[weaponType],
                        [5] = weaponType,
                        [6] = {
                            ["hitNum"] = hitNumCounter[weaponType],
                            ["onHitAnimName"] = weaponType .. slashCounter[weaponType],
                            ["hrtCF"] = attackCFrame
                        }
                    }

                    TNetSent:FireServer(unpack(args))
                    invokeID = invokeID + 1
                    if invokeID > 1853020188851841 then invokeID = 1 end
                    break
                end
            end

            hitNumCounter[weaponType] = hitNumCounter[weaponType] + 1
            if hitNumCounter[weaponType] > slashHit then
                hitNumCounter[weaponType] = 1
                slashCounter[weaponType] = slashCounter[weaponType] + 1
                if slashCounter[weaponType] > slashLimit then
                    slashCounter[weaponType] = 1
                end
            end

            Character:SetAttribute("AttackCooldown", false)
            task.wait(0.01)
        end
        cleanupDrawingObjects()
        Core.DungeonLootify.TargetCount = 0
        if Settings.DebugLogs.Value then
            print("Core.DungeonLootify.TargetCount reset to: 0")
        end
    end

    -- Create UI Section
    if UI and UI.Sections and UI.Sections.KillAuraSection and UI.Sections.TargetESP then
        local KillAuraSection = UI.Sections.KillAuraSection
        KillAuraSection:Header({ Name = "Kill Aura" })
        uiElements.EnabledKA = KillAuraSection:Toggle({
            Name = "Enabled",
            Default = Settings.Enabled.Default,
            Callback = function(value)
                Settings.Enabled.Value = value
                if value then
                    if not killAuraCoroutine or coroutine.status(killAuraCoroutine) == "dead" then
                        killAuraCoroutine = coroutine.create(runKillAura)
                        coroutine.resume(killAuraCoroutine)
                    end
                else
                    killAuraCoroutine = nil
                    cleanupDrawingObjects()
                    Core.DungeonLootify.TargetCount = 0
                    if Settings.DebugLogs.Value then
                        print("Core.DungeonLootify.TargetCount reset to: 0")
                    end
                end
                notify("KillAura", "Kill Aura " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'EnabledKA')
        KillAuraSection:Divider()
        uiElements.ShowCirclesKA = KillAuraSection:Toggle({
            Name = "Show Circles",
            Default = Settings.ShowCircles.Default,
            Callback = function(value)
                Settings.ShowCircles.Value = value
                if not value then
                    for _, indicator in ipairs(indicators) do
                        if indicator.circle and indicator.circle.Remove then
                            indicator.circle:Remove()
                        end
                        if indicator.connection then
                            indicator.connection:Disconnect()
                        end
                    end
                    table.clear(indicators)
                end
                notify("KillAura", "Circles " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'ShowCirclesKA')
        uiElements.MaxDistanceKA = KillAuraSection:Slider({
            Name = "Max Distance",
            Minimum = 10,
            Maximum = 500,
            Default = Settings.MaxDistance.Default,
            Precision = 0,
            Callback = function(value)
                Settings.MaxDistance.Value = value
                notify("KillAura", "Max Distance set to: " .. value)
                cachedTargets = findAllTargets()
                lastTargetUpdate = tick()
            end
        }, 'MaxDistanceKA')
        uiElements.EnableClusterKA = KillAuraSection:Toggle({
            Name = "Enable Cluster",
            Default = Settings.EnableCluster.Default,
            Callback = function(value)
                Settings.EnableCluster.Value = value
                notify("KillAura", "Cluster " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'EnableClusterKA')
        uiElements.ClusterRadiusKA = KillAuraSection:Slider({
            Name = "Cluster Radius",
            Minimum = 1,
            Maximum = 10,
            Default = Settings.ClusterRadius.Default,
            Precision = 1,
            Callback = function(value)
                Settings.ClusterRadius.Value = value
                notify("KillAura", "Cluster Radius set to: " .. value)
            end
        }, 'ClusterRadiusKA')
        uiElements.AttackHeightKA = KillAuraSection:Slider({
            Name = "Attack Height",
            Minimum = -2,
            Maximum = 2,
            Default = Settings.AttackHeight.Default,
            Precision = 1,
            Callback = function(value)
                Settings.AttackHeight.Value = value
                notify("KillAura", "Attack Height set to: " .. value)
            end
        }, 'AttackHeightKA')
        KillAuraSection:Divider()
        uiElements.UseRaycastKA = KillAuraSection:Toggle({
            Name = "Use Raycast",
            Default = Settings.UseRaycast.Default,
            Callback = function(value)
                Settings.UseRaycast.Value = value
                notify("KillAura", "Raycast " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'UseRaycastKA')
        uiElements.TestPredictKA = KillAuraSection:Toggle({
            Name = "Test Predict",
            Default = Settings.TestPredict.Default,
            Callback = function(value)
                Settings.TestPredict.Value = value
                notify("KillAura", "Predict " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'TestPredictKA')
        uiElements.PredictValueKA = KillAuraSection:Slider({
            Name = "Predict Value",
            Minimum = 0.01,
            Maximum = 1,
            Default = Settings.PredictValue.Default,
            Precision = 2,
            Callback = function(value)
                Settings.PredictValue.Value = value
                notify("KillAura", "Predict Value set to: " .. value)
            end
        }, 'PredictValueKA')
        uiElements.UpdateIntervalKA = KillAuraSection:Slider({
            Name = "Update Interval",
            Minimum = 0.01,
            Maximum = 1,
            Default = Settings.UpdateInterval.Default,
            Precision = 2,
            Callback = function(value)
                Settings.UpdateInterval.Value = value
                notify("KillAura", "Update Interval set to: " .. value)
            end
        }, 'UpdateIntervalKA')
        KillAuraSection:Divider()
        uiElements.DebugLogsKA = KillAuraSection:Toggle({
            Name = "Debug Logs",
            Default = Settings.DebugLogs.Default,
            Callback = function(value)
                Settings.DebugLogs.Value = value
                notify("KillAura", "Debug Logs " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'DebugLogsKA')

        local TargetESP = UI.Sections.TargetESP
        TargetESP:Header({ Name = "Target ESP" })
        uiElements.EnabledESPKA = TargetESP:Toggle({
            Name = "Enabled",
            Default = Settings.TargetESP.Enabled.Default,
            Callback = function(value)
                Settings.TargetESP.Enabled.Value = value
                if not value then
                    cleanupDrawingObjects()
                end
                notify("TargetESP", "ESP " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'EnabledESPKA')
        uiElements.PartsCountESPKA = TargetESP:Slider({
            Name = "Parts Count",
            Minimum = 10,
            Maximum = 70,
            Default = Settings.TargetESP.PartsCount.Default,
            Precision = 0,
            Callback = function(value)
                Settings.TargetESP.PartsCount.Value = value
                task.defer(createTargetESP)
                notify("TargetESP", "Parts Count set to: " .. value)
            end
        }, 'PartsCountESPKA')
        uiElements.GradientSpeedESPKA = TargetESP:Slider({
            Name = "Gradient Speed",
            Minimum = 0.1,
            Maximum = 10,
            Default = Settings.TargetESP.GradientSpeed.Default,
            Precision = 1,
            Callback = function(value)
                Settings.TargetESP.GradientSpeed.Value = value
                notify("TargetESP", "Gradient Speed set to: " .. value)
            end
        }, 'GradientSpeedESPKA')
        uiElements.CircleDistanceESPKA = TargetESP:Slider({
            Name = "Circle Distance",
            Minimum = 0.5,
            Maximum = 5,
            Default = Settings.TargetESP.CircleDistance.Default,
            Precision = 1,
            Callback = function(value)
                Settings.TargetESP.CircleDistance.Value = value
                notify("TargetESP", "Circle Distance set to: " .. value)
            end
        }, 'CircleDistanceESPKA')
        TargetESP:Divider()
        uiElements.YOffsetESPKA = TargetESP:Slider({
            Name = "Y Offset",
            Minimum = -5,
            Maximum = 5,
            Default = Settings.TargetESP.YOffset.Default,
            Precision = 1,
            Callback = function(value)
                Settings.TargetESP.YOffset.Value = value
                notify("TargetESP", "Y Offset set to: " .. value)
            end
        }, 'YOffsetESPKA')
        uiElements.AnimateCircleESPKA = TargetESP:Dropdown({
            Name = "Animate Circle",
            Options = {"None", "Jello", "Orbit", "OrbitSwirl"},
            Default = Settings.TargetESP.AnimateCircle.Default,
            Callback = function(value)
                Settings.TargetESP.AnimateCircle.Value = value
                task.defer(createTargetESP)
                notify("TargetESP", "Animation set to: " .. value, true)
            end
        }, 'AnimateCircleESPKA')
        uiElements.AnimationSpeedESPKA = TargetESP:Slider({
            Name = "Animation Speed",
            Minimum = 0.1,
            Maximum = 10,
            Default = Settings.TargetESP.AnimationSpeed.Default,
            Precision = 1,
            Callback = function(value)
                Settings.TargetESP.AnimationSpeed.Value = value
                notify("TargetESP", "Animation Speed set to: " .. value)
            end
        }, 'AnimationSpeedESPKA')
        TargetESP:Divider()
        uiElements.OrbitTiltESPKA = TargetESP:Slider({
            Name = "Orbit Tilt",
            Minimum = 0,
            Maximum = 3,
            Default = Settings.TargetESP.OrbitTilt.Default,
            Precision = 1,
            Callback = function(value)
                Settings.TargetESP.OrbitTilt.Value = value
                notify("TargetESP", "Orbit Tilt set to: " .. value)
            end
        }, 'OrbitTiltESPKA')
    end
        ConfigSync = UI.Tabs.Config:Section({ Name = "KillAura sync", Side = "Right" })
        ConfigSync:Header({ Name = "KillAura Settings Sync" })
        ConfigSync:Button({
            Name = "Sync Config",
            Callback = function()
                Settings.MaxDistance.Value = uiElements.MaxDistanceKA:GetValue()
                Settings.ClusterRadius.Value = uiElements.ClusterRadiusKA:GetValue()
                Settings.AttackHeight.Value = uiElements.AttackHeightKA:GetValue()
                Settings.PredictValue.Value = uiElements.PredictValueKA:GetValue()
                Settings.UpdateInterval.Value = uiElements.UpdateIntervalKA:GetValue()
                Settings.ShowCircles.Value = uiElements.ShowCirclesKA:GetState()
                -- Sync TargetESP sliders
                Settings.TargetESP.PartsCount.Value = uiElements.PartsCountESPKA:GetValue()
                Settings.TargetESP.GradientSpeed.Value = uiElements.GradientSpeedESPKA:GetValue()
                Settings.TargetESP.CircleDistance.Value = uiElements.CircleDistanceESPKA:GetValue()
                Settings.TargetESP.YOffset.Value = uiElements.YOffsetESPKA:GetValue()
                Settings.TargetESP.AnimationSpeed.Value = uiElements.AnimationSpeedESPKA:GetValue()
                Settings.TargetESP.OrbitTilt.Value = uiElements.OrbitTiltESPKA:GetValue()

                notify("KillAura", "Sliders synchronized!", true)
            end
        })
    return KillAura
end

return KillAura
